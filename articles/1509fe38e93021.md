---
title: "【PHP】クラス編~クラスの基礎、継承、アクセス権~"
emoji: "📘"
type: "tech"
topics:
  - "php"
  - "初心者"
  - "プログラミング"
published: true
published_at: "2021-09-19 22:34"
---

# クラスについて
オブジェクト指向に基づいた考え方で、データとデータを操作する処理（メソッド）を一つのオブジェクトと呼ばれる単位に一体化して扱う。あるオブジェクトがどのようなデータとメソッドから作られるのかを定義した、雛形にあたるものをクラスという。

### classの定義
クラスの定義は`class クラス名`として{}の間にそのクラスの内容を書いていきます。
クラスには**プロパティ**と**メソッド**の2つを定義します。それぞれの概要は以下です。

##### ・プロパティ
クラスがもつデータのことで、`public $プロパティ名`のように定義します。
`インスタンス->プロパティ名`とすることでアクセスすることができます。

##### ・メソッド
クラスに関連する処理（関数）のことで、`public function メソッド名()`のように定義します。
`インスタンス->メソッド名()`とすることでメソッドにアクセスすることができます。

```php
class SampleClass {
    public $name; // プロパティの宣言
    
    // メソッドの宣言
    public function hello($name) {
        echo 'こんにちは！'.$name;
    }
}
```

### インスタンス
インスタンスとはクラスを元に生成された実体で`new クラス名()`で生成します。
`$変数名 = new クラス名()`のようにすることでインスタンスを変数に代入し使用します。
```php
$sample = new SampleClass(); // インスタンスの生成

$sample->name = 'Kate'; // プロパティに値をセット

$sample->hello($sample->name); // メソッドの呼び出し。 引数：プロパティの呼び出し。

// 結果： こんにちは！Kate
```

# クラスの基礎

### コンストラクタ
`__construct`という特別なメソッドを定義することでインスタンスを生成するときに、このメソッドが自動的に呼ばれます。そのためコンストラクタには最初に行いたい処理を書きます。
またコンストラクタはインスタンス生成時に引数を渡すことでその引数を使用することが出来ます。

##### ・this
生成したインスタンスのプロパティやメソッドにアクセスしたい時には`$this`を用いります。
`$this`はクラス内のメソッドの中でのみ使用でき、そのメソッドを呼び出しているインスタンスに置き換えられます。
```php
class SampleClass {
    public $name;
    
    // コンストラクタの宣言
    public function __construct($name) {
        $this->name = $name; // 生成したインスタンスのプロパティにセット
    }
}

$sample1 = new SampleClass('Kate'); // コンストラクタに引数「'Kate'」が渡る
$sample2 = new SampleClass('Bob'); // コンストラクタに引数「'Bob'」が渡る

$sample1->name; // 結果： こんにちは！Kate
$sample2->name; // 結果： こんにちは！Bob
// それぞれのインスタンスにプロパティがセットされている
```

### static
個々のインスタンスに関係のないデータや処理を行う場合は`static`を用いて宣言することでクラスプロパティもしくはクラスメソッドを定義することができます。また、クラスのインスタンス化の必要なしにアクセスすることができます。

##### ・クラスプロパティ
クラスプロパティは`static 変数名`のように定義し、`クラス名::$クラスプロパティ名`で呼び出すことができます。

##### ・クラスメソッド
クラスメソッドは`static メソッド名`のように定義し、`クラス名::クラスメソッド名`で呼び出すことができます。

##### ・self
クラス内でクラスプロパティにアクセスする際は`self`を用います。
`self`は、クラスの中で使うとそのクラス自身のことを指し示し、`self::$クラスプロパティ名`のように使います。

```php
class SampleClass {
    public static $count = 0; // クラスプロパティの宣言
    
    public function __construct() {
	self::$count++; // クラスプロパティにアクセス
    }
    
    // クラスメソッドの宣言
    public satic function number() {
	echo 'このクラスのインスタンスが生成数は'.self::$count.'です';
    }
}
// インスタンス生成
$sample1 = new SampleClass();
$sample2 = new SampleClass();

echo SampleClass::$count; // クラスプロパティの呼び出し
// 結果： 2
SampleClass::number(); // クラスメソッドの呼び出し
// 結果： このクラスのインスタンスが生成数は2です
```


# 継承
すでに定義されているクラスのプロパティやメソッドを別のクラスに引き継ぐことを**継承**といいます。この時、元のクラスを**親クラス**、継承して新しくできるクラスを**子クラス**といいます。
継承を行う場合は「class 子クラス名 extends 親クラス名」のように定義します。
子クラスは、親クラスのプロパティやメソッドを全て引き継いだ上で、独自プロパティ、独自メソッドを定義できます。

### オーバーライド
**オーバーライド**は親クラスで定義されたメソッドを子クラスで再定義することで別の処理に上書きすることができます。

#### parent
オーバーライドの際に親クラスで定義したメソッドを呼び出したいときには、`parent::メソッド名`のように記述することで親クラスのメソッドが実行されます。

```php
// 親クラス
class ParentClass {
    public $name;
    
    public function greeting($name) {
	echo '初めまして、'.$name.'です。';
    }
}

// 親クラスを継承した子クラス
class ChildClass extends　ParentClass　{
    public $age;
    
    // オーバーライド
    public function greeting($name, $age) {
        parent::greeting($name);　// 親クラスのメソッド実行
	echo $age.'歳です';
    }
}

$parent = new ParentClass();
$parent->greeting('Kate'); // 結果： 初めまして、Kateです

$child = new ChildClass();
$child->greeting('Kate', '25'); // 結果： 初めまして、Kateです。25歳です
```

# アクセス権
上記でクラスのプロパティやメソッドを定義する際に`public ~~`と記載していましたがこの`public`を**修飾子**といい、そのプロパティやメソッドへのアクセスを制限することができます。
修飾子には以下の3つのアクセス権があり、許可した範囲からしかアクセスすることができません。
- `public`: どこからでもアクセス可能
- `protected`: そのクラスと子クラス内からのみアクセス可能
- `private`: そのクラス内からのみアクセス可能

| アクセス権 | public | protected | private |
| ---- | ---- | ---- | ---- |
| 定義したクラス内| ○ | ○ | ○ |
| 子クラス| ○ | ○ | × |
| クラス、子クラスの外| ○ | × | × |

### カプセル化
クラスのプロパティとメソッドへのアクセスを制限することを**カプセル化**と言い、クラスを設計する際には他の人がそのクラスを利用しやすいように、使ってほしい機能は公開(`public`)し、クラスの外で使ってほしくない機能は隠(`private`)します。
使える機能を制限することで他の人はどの機能を使えばいいかが分かりやすく、安全にクラスを利用することができます。